// массив из 15 элементов в котором 1 и последний 1 - 1, остальное 0
let root = document.getElementById("root"); // тот элемент который в который нас будет все писаться


//здесь у нас небольшой закос по реакт. первый аргумент принимает фразу в строке, второй у нас принимает элемент который он вывводит на страницу
function render(vivod = "", el){
    root.insertAdjacentHTML("beforebegin", `<h3>${vivod} : ${el} </h3>`);
    //тут я поменял на beforebegin, что бы рисовалось в нормальном порядке.
}



// здесь у нас задача  про то, что нужно создать массив из нулей, в котором у нас первый и последний элемент единицы
let arr = [];  // просто пустой массив
for (let i = 0; i < 13; i++) {
   arr[i] = 0; //наполнение нулями
}
arr.push(1); // добавление единицы в конец 
arr.unshift(1); // добавление единицы в начало

render("Первая задача", arr); // сама отрисовка


/*
ВЕСЕЛЬЕ НАЧИНАЕТСЯ ЗДЕСЬ
*/

// Задача: Найти наиболее часто встречающийся элемент в массиве целых чисел

let arr1 = [13,23,45,32,23,23,45,33,33,45,67,23,345,23];


// arr1= [13,23,45,32,23,23,45,33,33,33,33,33,33,33,45,67,67,67,67,67,67,6,67,67,67,67,67,67,23,345,23];  это для теста. Можете попробовать изменить у массив на любые числа, интересно поискать баги и ошибки в работе
render('Исходный масссив', arr1);
// Вот наш массив, может быть любой длинны, с любыми числами

arr1.sort((a, b) =>  {
    return a - b;
    // здесь просто происходит сортировка от меньшего к большему
    // кроме того я переделал все на arrow function - стильно, модно, хотя и не так понятно
});

// стоит помнить, что мерзкий sort делает сортировку, изменяя ИСХОДНЫЙ массив. Если вы этого не хотите, Array.from в помощь

render('здесь у нас теперь отсортированный исходный массив', arr1);


let count = [];  // этот массив посвящен количеству каждого из упомянутых элементов
var j = 1; // счетчик сколько
var k = 1;  // о неудачная буква. теперь это k
for(let i = 0; i < arr1.length; i++) {
    if(arr1[i]==arr1[k]){
        ++j;
    }else{
        count.push(j);
        j=1;
    }
    k++;
}
render('- массив с частотами', count);

let count1 = []; // нам потребуется пустой массив, в который мы запишем массив с частотами и отсортируем его от меньшего к большему

count1 = Array.from(count);
// создаем копию, а не работаем с ссылочными типами


count1.sort(function(a, b) {
    return a - b;
});
render("отсортированная копия  частот", count1);

let count_piece = []; // это пустой массив, в который мы вырежем кусочек массива до из count,
// что бы потом посчитать его сумму

let x = count1.length; 
render(" длина отсортированной копии частот", x);
console.log(count1[x-1]);  //тут типичная проблема тупых языков программирования, еще в 70 придумали эту технологию * грязные ругательства*  Дело в том,  что индексирование идет от 0,  а отсчет для length - c единицы))))))))))))


for(let i = 0; i < x; i++){   
    // если у нас элемент из неотсортированного массива частот совпадет с последним элементом 
    //в сортированном - берем срез неотсортированного массива
    if(count[i] == count1[x-1]){
        count_piece = count.slice(0, ++i);  // вот тут срез 
    }
    
}


// теперь нам осталось посчитать сумму элементов в массиве count_piece
// попробуем через стандартный for 
var sum = 0;
for (let i = 0; i < count_piece.length; i++) {
    sum = sum + count_piece[i];
}
alert(count_piece);
alert(sum);
render('итого, максимальное число у нас является', arr1[sum-1]);



